"""
Predicted 12-month appreciation lookup per ZIP code.

Uses the pre-computed zip_rankings.csv generated by the XGBoost training
pipeline. Falls back to live model prediction if the joblib exists and
the ZIP isn't in the CSV.
"""
from __future__ import annotations

import os
from functools import lru_cache
from typing import Optional

import numpy as np
import pandas as pd

from app.core.config import ZHVI_CSV_PATH

_OUTPUT_DIR = os.path.normpath(
    os.path.join(os.path.dirname(__file__), "..", "..", "output")
)
_RANKINGS_PATH = os.path.join(_OUTPUT_DIR, "zip_rankings.csv")
_XGB_MODEL_PATH = os.path.join(_OUTPUT_DIR, "xgb_model.joblib")


@lru_cache(maxsize=1)
def _load_rankings() -> dict[str, float]:
    """Load ZIP â†’ predicted appreciation mapping from the rankings CSV."""
    if not os.path.exists(_RANKINGS_PATH):
        return {}
    df = pd.read_csv(_RANKINGS_PATH)
    df["RegionName"] = df["RegionName"].astype(str).str.zfill(5)
    return dict(zip(df["RegionName"], df["predicted_12m_appreciation"]))


@lru_cache(maxsize=1)
def _load_model():
    """Attempt to load the trained XGBoost model."""
    if not os.path.exists(_XGB_MODEL_PATH):
        return None
    import joblib
    return joblib.load(_XGB_MODEL_PATH)


def _compute_features_for_zip(zip_code: str) -> Optional[np.ndarray]:
    """Build the 6-feature vector for the latest month of a given ZIP."""
    try:
        from app.services.zhvi_loader import get_zip_series
        values = get_zip_series(zip_code)
    except (ValueError, Exception):
        return None

    if len(values) < 37:
        return None

    prices = values.astype(float)
    n = len(prices)

    growth_3m = prices[-1] / prices[-4] - 1 if n >= 4 else np.nan
    growth_6m = prices[-1] / prices[-7] - 1 if n >= 7 else np.nan
    growth_12m = prices[-1] / prices[-13] - 1 if n >= 13 else np.nan

    ratio_36 = prices[-1] / prices[-37] if n >= 37 else np.nan
    cagr_3y = ratio_36 ** (12.0 / 36.0) - 1 if np.isfinite(ratio_36) else np.nan

    monthly_ret = np.diff(prices[-13:]) / prices[-13:-1] if n >= 13 else np.array([])
    volatility_12m = float(np.std(monthly_ret, ddof=1)) if len(monthly_ret) >= 2 else np.nan

    momentum_accel = growth_3m - growth_6m

    feat = np.array([growth_3m, growth_6m, growth_12m, cagr_3y, volatility_12m, momentum_accel])
    if not np.all(np.isfinite(feat)):
        return None
    return feat.reshape(1, -1)


def get_appreciation(zip_code: str) -> Optional[float]:
    """Return predicted 12-month appreciation for a ZIP code (as a decimal, e.g. 0.05 = +5%)."""
    zip_str = str(zip_code).zfill(5)

    rankings = _load_rankings()
    if zip_str in rankings:
        return rankings[zip_str]

    model = _load_model()
    if model is not None:
        features = _compute_features_for_zip(zip_str)
        if features is not None:
            pred = float(model.predict(features)[0])
            return pred

    return None


def get_appreciation_bulk(zip_codes: list[str]) -> dict[str, Optional[float]]:
    """Return predicted appreciation for multiple ZIPs at once."""
    return {z: get_appreciation(z) for z in zip_codes}
